struct record{
	int value;
	record* parent;
	record* left;
	record* right;
};


record root;
(*root).parent = NIL;


void transversalOrder(record* node) {
	if(*node == NIL){
		return;
	}
	transversalOrder((*node).left);
	cout<<((*node).value);
	transversalOrder(*(node).right);
}


record* subtreeFirst(record* node){
	if((*node).left != NIL){
		subtreeFirst((*node).left);
	}else{
		return node;
	}
}


record* subtreeFirst_alt (record* node){
	if((*node).left != NIL){
		while((*node).left != NIL){
			node = (*node).left;
		}
	}
	return node;
}


record* successor (record* node){ /*Exclude the circumstance that there is no successor*/
	if((*node).right != NIL)){
		return subtreeFirst((*node).right);
	}else{ /*Include the circumstance that the node itself is located in a left branch*/
		while((*(*node).parent).left != node){
			node = (*node).parent;
		}
		return (*node).parent;
	}
}	

void insertAfter (record* node, int value){
	record* new;
	new = (record*) malloc (sizeof(record));
	(*new).value = value;
	/*Assign space to new element*/
	if((*node).right == NIL){
		(*node).right = new;
		(*new).parent = node;
	}else{
		(*(subtreeFirst((*node)).right)).left = new;
		(*new).parent = subtreeFirst((*node)).right);
	}
}

void insertBefore (record* node, int value){
	record* new;
	new = (record*) malloc (sizeof(record));
	(*new).value = value;
	/*Assign space to new element*/
	if((*node).left == NIL){
		(*node).left = new;
		(*new).parent = node;
	}else{
		node = (*node).left;
		while((*node).right != NIL){
			node = (*node).right;
		}
		(*node).left = new;
		(*new).parent = node;
	}
}

void delete (record* node){
	if((*node).left == NIL || (*node).right == NIL){
		if(((*node).parent).left == node){
			((*node).parent).left == NIL;
			free(*node);
		}else{
			((*node).parent).right == NIL;
			free(*node);
		}
	}else{
		
	}
}